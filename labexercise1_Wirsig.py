# -*- coding: utf-8 -*-
"""LabExercise1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bxa21BxR9kkyWFn57CPvTfJEGS4hnzdu

# Bergische Universität Wuppertal #

**Fakultät Mathematik und Naturwissenschaften** 

**Angewandte Mathematik/Numerische Analysis**

*Dr. L. Teng*

*L. Kapllani, M.Sc.* 

*Summerterm 2021*

# Computational Finance I
**Lab-Exercise No. 1**

# P1: Trinomial Tree
In the lecture we mentioned that a binomial model can be generalized to a trinomial model. In a trinomial model we need to consider three stock price developments: in one period the price increases by a factor of $u$ with the probability $p_u$, descreases by a factor of $d$ with the probability $p_d$, or remains unchanged with the probability $1−p_u −p_d$. The trinomial model can be built in a similar way to the binomial model, e.g., by matching the expectation and the variance and using $ud = 1$ we obtain:
    $$ u = e^{\sigma\sqrt{2\Delta t}}, \quad d = e^{-\sigma\sqrt{2\Delta t}}, \quad p_d = \left( \frac{ e^{\sigma\sqrt{\frac{\Delta t}{2}}} - e^{r\frac{\Delta t}{2}} }{e^{\sigma\sqrt{\frac{\Delta t}{2}}} - e^{-\sigma\sqrt{\frac{\Delta t}{2}}}} \right)^2, \quad \quad p_u = \left( \frac{ e^{r\frac{\Delta t}{2}} - e^{-\sigma\sqrt{\frac{\Delta t}{2}}}}{e^{\sigma\sqrt{\frac{\Delta t}{2}}} - e^{-\sigma\sqrt{\frac{\Delta t}{2}}}} \right)^2.$$

For the programming task write the corresponding Python functions that are asked in each section below.

**Return the solutions of the programming task $\href{https://moodle.uni-wuppertal.de/mod/assign/view.php?id=762093}{{here}}$ until Friday, May 21. The assignment can be done in groups of 1-2 persons. The solution should be presented within the following 2 weeks via an online arranged ZOOM meeting with M.Sc. Lorenc Kapllani.**

## Write your data
"""

print("First Name: Dominik")
print("Sure Name: Wirsig")
print("Matriculation number: 2020067")
print("E-mail: 2020067@uni-wuppertal.de")
print("Degree Type: Master") # Bachelor or Master
print("Degree Name: Master of Science in Computer Simulation in Science") # E.g. Master of Science in Computer Simulation in Science

"""## Import all necessary modules"""

import math
import numpy as np

"""## Test Parameters"""

# Input parameters
sigma = 0.2
K = 100
S0 = 100
N = 4
r = 0.05
T = 1
d_t = T / N

"""# Start coding
**Note:** 
* Add code where you find the comment "# Add code here"
* Get the same output as it is presented in the Markdown text **Expected Output:**

## Define a function to calculate the up and down factors
"""

def calc_ud(sigma, d_t):
    """
    Function that calculates the factors in the trinomial model

    Input: sigma -> volatility 
            d_t  -> time step size

    Output: u -> upward movement
            d -> downward movement

    """
    u = math.exp(sigma * math.sqrt(2 * d_t))
    d = math.exp(-sigma * math.sqrt(2 * d_t))
    return u, d

# Calculate upward and downward movements
u, d = calc_ud(sigma, d_t)
print('u = %.6f, d = %.6f' % (u, d))

"""**Expected Output:**
`u = 1.151910, d = 0.868123`

## Define a function to calculate the probabilities in the trinomial model
"""

def calc_prob(r, sigma, d_t):
    """
    Function that calculates the probabilities in the trinomial model

    Input: r     -> interest rate
           sigma -> volatility
           d_t   -> time step size

    Output: p_u -> probability for upward movement
            p_d -> probability for downward movement
            p_m -> probability for no change

    """
    p_u = ((math.exp(r*d_t/2) - math.exp(-sigma*math.sqrt(d_t/2))) / (math.exp(sigma*math.sqrt(d_t/2)) - math.exp(-sigma*math.sqrt(d_t/2)))) ** 2
    p_d = ((math.exp(sigma*math.sqrt(d_t/2)) - math.exp(r*d_t/2)) / (math.exp(sigma*math.sqrt(d_t/2)) - math.exp(-sigma*math.sqrt(d_t/2)))) ** 2
    p_m = 1 - p_u - p_d
    return p_u, p_d, p_m

# Calculate probabilities
p_u, p_d, p_m = calc_prob(r, sigma, d_t)
print('p_u = %.6f, p_d = %.6f, p_m = %.6f' % (p_u, p_d, p_m))

"""**Expected Output:**
`p_u = 0.277334, p_d = 0.224084, p_m = 0.498582`

## Define a function to calculate the stock prices in the trinomial model
"""

def stock_price_trinom(S0, N, u, d):
    
    """
    Function that calculates the stock prices in the trinomial model
    
    Input: S0 -> Initial Stock Price
           u  -> upward movement
           d  -> downward movement
           N  -> Number of time periods
       
    Output: S -> Upper triangular matrix of Stock prices with tirnomial model
    """
    S = np.zeros((2*N + 1, N + 1))
    for j in range(0, N + 1):
      for i in range(0, 2*j + 1):
        S[i,j] = S0 * (u ** (j-i)) # u=1/d => u^(-1)=d, u^(-2)=d^2,...
    return S

# Calculate stock prices
S = stock_price_trinom(S0, N, u, d)
print("Stock Prices")
print(S)

"""**Expected Output:**

`Stock Prices`

`[[100.         115.19099102 132.68964411 152.84651603 176.06541655]
 [  0.         100.         115.19099102 132.68964411 152.84651603]
 [  0.          86.81234454 100.         115.19099102 132.68964411]
 [  0.           0.          86.81234454 100.         115.19099102]
 [  0.           0.          75.36383164  86.81234454 100.        ]
 [  0.           0.           0.          75.36383164  86.81234454]
 [  0.           0.           0.          65.42510919  75.36383164]
 [  0.           0.           0.           0.          65.42510919]
 [  0.           0.           0.           0.          56.7970712 ]]`

## Define a function to calculate the European option price using trinomial model
"""

def priceTriEuro(N, K, r, S, p_u, p_d, p_m, d_t):
    """
    Function that calculates the European option price using trinomial model
    
    Input: N     -> Number of time periods
           K     -> Strike price
           r     -> Interst rate
           S     -> Upper triangular matrix
           p_u   -> probability for upward movement
           p_d   -> probability for downward movement
           p_m   -> probability for no change
           d_t   -> time step size
       
    Output: C -> European Call option 
            P -> European Put option 

    """
    C = np.zeros((2*N + 1, N + 1))
    P = np.zeros((2*N + 1, N + 1))

    # last column payoff
    for i in range(0, 2*N + 1):
      C[i][N] = max(S[i][N] - K, 0)
      P[i][N] = max(K - S[i][N], 0)

    # Backward (value) iteration for options
    for i in range(N-1, -1, -1):
      for j in range(0,  i*2 + 1):
          C[j][i] = math.exp(-r*d_t) * (p_u*C[j][i+1] + p_m*C[j+1][i+1] + p_d*C[j+2][i+1])
          P[j][i] = math.exp(-r*d_t) * (p_u*P[j][i+1] + p_m*P[j+1][i+1] + p_d*P[j+2][i+1])
    return C, P

# Calculate European call and put values
C, P = priceTriEuro(N, K, r, S, p_u, p_d, p_m, d_t)
print('European Call')
print(C)
print('European Put')
print(P)

"""**Expected Output:**

`European Call`

`[[10.20509942 20.0925775  35.15865291 54.08873598 76.06541655]
 [ 0.          8.49087322 18.30584772 33.93186407 52.84651603]
 [ 0.          2.35495086  6.54953395 16.43321097 32.68964411]
 [ 0.          0.          1.13955621  4.16064756 15.19099102]
 [ 0.          0.          0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.        ]]`

`European Put`

`[[ 5.32804187  1.22102826  0.          0.          0.        ]
 [ 0.          4.810315    0.64584791  0.          0.        ]
 [ 0.         11.86204809  4.08052515  0.          0.        ]
 [ 0.          0.         11.85820287  2.91842761  0.        ]
 [ 0.          0.         22.16715956 11.94543551  0.        ]
 [ 0.          0.          0.         23.39394841 13.18765546]
 [ 0.          0.          0.         33.33267086 24.63616836]
 [ 0.          0.          0.          0.         34.57489081]
 [ 0.          0.          0.          0.         43.2029288 ]]`

## Define a function to calculate the American option price using trinomial model
"""

def priceTriAmer(N, K, r, S, p_u, p_d, p_m, d_t):
    """
    Function that calculates the American option price using trinomial model
    
    Input: N     -> Number of time periods
           K     -> Strike price
           r     -> Interst rate
           S     -> Upper triangular matrix
           p_u   -> probability for upward movement
           p_d   -> probability for downward movement
           p_m   -> probability for no change
           d_t   -> time step size
       
    Output: C -> American Call option 
            P -> American Put option 

    """
    C = np.zeros((2*N + 1, N + 1))
    P = np.zeros((2*N + 1, N + 1))

    # last column payoff
    for i in range(0, 2*N + 1):
      C[i][N] = max(S[i][N] - K, 0)
      P[i][N] = max(K - S[i][N], 0)

    # Backward (value) iteration for options
    for i in range(N-1, -1, -1):
      for j in range(0,  i*2 + 1):
          C_temp = math.exp(-r*d_t) * (p_u*C[j][i+1] + p_m*C[j+1][i+1] + p_d*C[j+2][i+1])
          C[j][i] = max(S[j][i] - K, C_temp)
          P_temp = math.exp(-r*d_t) * (p_u*P[j][i+1] + p_m*P[j+1][i+1] + p_d*P[j+2][i+1])
          P[j][i] = max(K - S[j][i], P_temp)
    return C, P

# Calculate American call and put values
C, P = priceTriAmer(N, K, r, S, p_u, p_d, p_m, d_t)
print('American Call')
print(C)
print('American Put')
print(P)

"""**Expected Output:**

`American Call`

`[[10.20509942 20.0925775  35.15865291 54.08873598 76.06541655]
 [ 0.          8.49087322 18.30584772 33.93186407 52.84651603]
 [ 0.          2.35495086  6.54953395 16.43321097 32.68964411]
 [ 0.          0.          1.13955621  4.16064756 15.19099102]
 [ 0.          0.          0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.        ]]`

`American Put`

`[[ 5.84957502  1.28186433  0.          0.          0.        ]
 [ 0.          5.23988204  0.64584791  0.          0.        ]
 [ 0.         13.18765546  4.35542837  0.          0.        ]
 [ 0.          0.         13.18765546  2.91842761  0.        ]
 [ 0.          0.         24.63616836 13.18765546  0.        ]
 [ 0.          0.          0.         24.63616836 13.18765546]
 [ 0.          0.          0.         34.57489081 24.63616836]
 [ 0.          0.          0.          0.         34.57489081]
 [ 0.          0.          0.          0.         43.2029288 ]]`

## Comparing European and American option values calculated with Trinomial Model from the exact Solution
"""

# Calculate European and American put values for different N and compare to exact solution
# Exact Values
E_P_ex = 5.5735
A_P_ex = 6.0624
N = [4, 16, 64, 256, 512, 1024]

for i in N:
  d_t = T / i
  u, d = calc_ud(sigma, d_t)
  p_u, p_d, p_m = calc_prob(r, sigma, d_t)
  S = stock_price_trinom(S0, i, u, d)
  C, E_P_app = priceTriEuro(i, K, r, S, p_u, p_d, p_m, d_t)

  err_E_P = abs(E_P_ex - E_P_app[0][0])
  print('N = %4.d, E_P_ex = %2.6f, E_P_app = %2.6f, err_E_P = %e' % (i, E_P_ex, E_P_app[0][0], err_E_P))

print()

for i in N:
  d_t = T / i
  u, d = calc_ud(sigma, d_t)
  p_u, p_d, p_m = calc_prob(r, sigma, d_t)
  S = stock_price_trinom(S0, i, u, d)
  C, A_P_app = priceTriAmer(i, K, r, S, p_u, p_d, p_m, d_t)
  
  err_A_P = abs(A_P_ex - A_P_app[0][0])
  print('N = %4.d, A_P_ex = %2.6f, A_P_app = %2.6f, err_A_P = %e' % (i, A_P_ex, A_P_app[0][0], err_A_P))

"""**Expected Output:**
![title](trinom_tree.png)
"""

# feel free to use this cell for additional tests

# feel free to use this cell for additional tests

# feel free to use this cell for additional tests

# feel free to use this cell for additional tests



